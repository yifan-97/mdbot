"use strict";
/**
 * @module botbuilder-dialogs
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const botbuilder_core_1 = require("botbuilder-core");
const dialogContext_1 = require("./dialogContext");
const dialog_1 = require("./dialog");
const configurable_1 = require("./configurable");
const dialogSet_1 = require("./dialogSet");
const memory_1 = require("./memory");
const dialogEvents_1 = require("./dialogEvents");
const dialogTurnStateConstants_1 = require("./dialogTurnStateConstants");
const LAST_ACCESS = '_lastAccess';
const CONVERSATION_STATE = 'ConversationState';
const USER_STATE = 'UserState';
class DialogManager extends configurable_1.Configurable {
    constructor(rootDialog, dialogStateProperty) {
        super();
        this.dialogSet = new dialogSet_1.DialogSet();
        this._initialTurnState = new botbuilder_core_1.TurnContextStateCollection();
        if (rootDialog) {
            this.rootDialog = rootDialog;
        }
        this.dialogStateProperty = dialogStateProperty || 'DialogStateProperty';
        this._initialTurnState.set(dialogTurnStateConstants_1.DialogTurnStateConstants.dialogManager, this);
    }
    /**
     * Values that will be copied to the `TurnContext.turnState` at the beginning of each turn.
     */
    get initialTurnState() {
        return this._initialTurnState;
    }
    /**
     * Root dialog to start from [onTurn()](#onturn) method.
     */
    set rootDialog(dialog) {
        this.dialogSet.add(dialog);
        this.rootDialogId = dialog.id;
    }
    get rootDialog() {
        return this.rootDialogId ? this.dialogSet.find(this.rootDialogId) : undefined;
    }
    configure(config) {
        return super.configure(config);
    }
    onTurn(context) {
        return __awaiter(this, void 0, void 0, function* () {
            // Ensure properly configured
            if (!this.rootDialogId) {
                throw new Error(`DialogManager.onTurn: the bot's 'rootDialog' has not been configured.`);
            }
            // Copy initial turn state to context
            this.initialTurnState.forEach((value, key) => {
                context.turnState.set(key, value);
            });
            const botStateSet = new botbuilder_core_1.BotStateSet();
            if (!this.conversationState) {
                this.conversationState = context.turnState.get(CONVERSATION_STATE);
            }
            else {
                context.turnState.set(CONVERSATION_STATE, this.conversationState);
            }
            if (!this.conversationState) {
                throw new Error(`DialogManager.onTurn: the bot's 'conversationState' has not been configured.`);
            }
            botStateSet.add(this.conversationState);
            if (!this.userState) {
                this.userState = context.turnState.get(USER_STATE);
            }
            else {
                context.turnState.set(USER_STATE, this.userState);
            }
            if (this.userState) {
                botStateSet.add(this.userState);
            }
            // Get last access
            const lastAccessProperty = this.conversationState.createProperty(LAST_ACCESS);
            const lastAccess = new Date(yield lastAccessProperty.get(context, new Date().toISOString()));
            // Check for expired conversation
            const now = new Date();
            if (this.expireAfter != undefined && (now.getTime() - lastAccess.getTime()) >= this.expireAfter) {
                // Clear conversation state
                yield this.conversationState.clear(context);
            }
            // Update last access time
            yield lastAccessProperty.set(context, lastAccess.toISOString());
            // get dialog stack 
            const dialogsProperty = this.conversationState.createProperty(this.dialogStateProperty);
            const dialogState = yield dialogsProperty.get(context, {});
            // Create DialogContext
            const dc = new dialogContext_1.DialogContext(this.dialogSet, context, dialogState);
            // Configure dialog state manager and load scopes
            const dialogStateManager = new memory_1.DialogStateManager(dc, this.stateConfiguration);
            yield dialogStateManager.loadAllScopes();
            let turnResult;
            while (true) {
                try {
                    if (dc.activeDialog) {
                        // Continue dialog execution
                        // - This will apply any queued up interruptions and execute the current/next step(s).
                        turnResult = yield dc.continueDialog();
                        if (turnResult.status == dialog_1.DialogTurnStatus.empty) {
                            // Begin root dialog
                            turnResult = yield dc.beginDialog(this.rootDialogId);
                        }
                    }
                    else {
                        turnResult = yield dc.beginDialog(this.rootDialogId);
                    }
                    break;
                }
                catch (err) {
                    const handled = yield dc.emitEvent(dialogEvents_1.DialogEvents.error, err, true, true);
                    if (!handled) {
                        throw err;
                    }
                }
            }
            // Save any memory changes
            yield dialogStateManager.saveAllChanges();
            // Save BotState changes
            yield botStateSet.saveAllChanges(dc.context, false);
            // Send trace of memory to emulator
            const snapshot = dc.state.getMemorySnapshot();
            yield dc.context.sendActivity({
                type: botbuilder_core_1.ActivityTypes.Trace,
                name: 'BotState',
                valueType: 'https://www.botframework.com/schemas/botState',
                value: snapshot,
                label: 'Bot State'
            });
            return { turnResult: turnResult };
        });
    }
}
exports.DialogManager = DialogManager;
//# sourceMappingURL=dialogManager.js.map