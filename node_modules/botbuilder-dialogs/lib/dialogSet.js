"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const dialog_1 = require("./dialog");
const dialogContext_1 = require("./dialogContext");
/**
 * A related set of dialogs that can all call each other.
 *
 * @remarks
 * The constructor for the dialog set should be passed a state property that will be used to
 * persist the dialog stack for the set:
 *
 * ```JavaScript
 * const { ConversationState, MemoryStorage, ActivityTypes } = require('botbuilder');
 * const { DialogSet, Dialog, DialogTurnStatus } = require('botbuilder-dialogs');
 *
 * const convoState = new ConversationState(new MemoryStorage());
 * const dialogState = convoState.createProperty('dialogState');
 * const dialogs = new DialogSet(dialogState);
 * ```
 *
 * The bot can add dialogs or prompts to the set using the [add()](#add) method:
 *
 * ```JavaScript
 * class GreetingDialog extends Dialog {
 *     async beginDialog(dc, options) {
 *         await dc.context.sendActivity(`Hi! I'm a bot.`);
 *         return await dc.endDialog();
 *     }
 * }
 *
 * dialogs.add(new GreetingDialog('greeting'));
 * ```
 *
 * To interact with the sets dialogs you can call [createContext()](#createcontext) with the
 * current `TurnContext`. That will create a `DialogContext` that can be used to start or continue
 * execution of the sets dialogs:
 *
 * ```JavaScript
 * // Create DialogContext for the current turn
 * const dc = await dialogs.createContext(turnContext);
 *
 * // Try to continue executing an active multi-turn dialog
 * const result = await dc.continueDialog();
 *
 * // Send greeting if no other dialogs active
 * if (result.status == DialogTurnStatus.empty && dc.context.activity.type == ActivityTypes.Message) {
 *     await dc.beginDialog('greeting');
 * }
 * ```
 */
class DialogSet {
    /**
     * Creates a new DialogSet instance.
     *
     * @remarks
     * If the `dialogState` property is not passed in, calls to [createContext()](#createcontext)
     * will return an error.  You will need to create a `DialogContext` for the set manually and
     * pass in your own state object for persisting the sets dialog stack:
     *
     * ```JavaScript
     * const dc = new DialogContext(dialogs, turnContext, state);
     * ```
     * @param dialogState (Optional) state property used to persist the sets dialog stack.
     */
    constructor(dialogState) {
        this.dialogs = {};
        this.dialogState = dialogState;
    }
    /**
     * Returns a 32-bit hash of the all the `Dialog.version` values in the set.
     *
     * @remarks
     * This hash is persisted to state storage and used to detect changes to a dialog set.
     */
    getVersion() {
        if (!this._version) {
            let versions = '';
            for (const id in this.dialogs) {
                const v = this.dialogs[id].getVersion();
                if (v) {
                    versions += `|${v}`;
                }
            }
            this._version = computeHash(versions);
        }
        return this._version;
    }
    /**
     * Adds a new dialog or prompt to the set.
     *
     * @remarks
     * If the `Dialog.id` being added already exists in the set, the dialogs id will be updated to
     * include a suffix which makes it unique. So adding 2 dialogs named "duplicate" to the set
     * would result in the first one having an id of "duplicate" and the second one having an id
     * of "duplicate2".
     * @param dialog The dialog or prompt to add.
     * If a telemetryClient is present on the dialog set, it will be added to each dialog.
     */
    add(dialog) {
        if (!(dialog instanceof dialog_1.Dialog)) {
            throw new Error(`DialogSet.add(): Invalid dialog being added.`);
        }
        // Ensure new version hash is computed
        this._version = undefined;
        // Ensure dialogs ID is unique.
        if (this.dialogs.hasOwnProperty(dialog.id)) {
            let nextSuffix = 2;
            while (true) {
                const suffixId = dialog.id + nextSuffix.toString();
                if (!this.dialogs.hasOwnProperty(suffixId)) {
                    dialog.id = suffixId;
                    break;
                }
                else {
                    nextSuffix++;
                }
            }
        }
        // If a telemetry client has already been set on this dialogSet, also set it on new dialogs as they are added.
        if (this._telemetryClient) {
            dialog.telemetryClient = this._telemetryClient;
        }
        // Save dialog reference
        this.dialogs[dialog.id] = dialog;
        // Automatically add any child dependencies the dialog might have
        if (typeof dialog.getDependencies == 'function') {
            dialog.getDependencies().forEach((child) => {
                this.add(child);
            });
        }
        return this;
    }
    /**
     * Creates a dialog context which can be used to work with the dialogs in the set.
     * @param context Context for the current turn of conversation with the user.
     */
    createContext(context) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.dialogState) {
                throw new Error(`DialogSet.createContextAsync(): the dialog set was not bound to a stateProperty when constructed.`);
            }
            const state = yield this.dialogState.get(context, { dialogStack: [] });
            return new dialogContext_1.DialogContext(this, context, state);
        });
    }
    /**
     * Finds a dialog that was previously added to the set using [add()](#add).
     *
     * @remarks
     * This example finds a dialog named "greeting":
     *
     * ```JavaScript
     * const dialog = dialogs.find('greeting');
     * ```
     * @param dialogId ID of the dialog or prompt to lookup.
     */
    find(dialogId) {
        return this.dialogs.hasOwnProperty(dialogId) ? this.dialogs[dialogId] : undefined;
    }
    /**
     * Set the telemetry client for this dialog set and apply it to all current dialogs.
     */
    get telemetryClient() {
        return this._telemetryClient;
    }
    /**
     * Set the telemetry client for this dialog set and apply it to all current dialogs.
     * Future dialogs added to the set will also inherit this client.
     */
    set telemetryClient(client) {
        this._telemetryClient = client;
        for (let key in this.dialogs) {
            this.dialogs[key].telemetryClient = this._telemetryClient;
        }
    }
}
exports.DialogSet = DialogSet;
/**
 * Generates a 32 bit hash for a string.
 *
 * @remarks
 * The source for this function was derived from the following article:
 *
 * https://werxltd.com/wp/2010/05/13/javascript-implementation-of-javas-string-hashcode-method/
 *
 * @param text String to generate a hash for.
 * @returns A string that is 15 characters or less in length.
 */
function computeHash(text) {
    const l = text.length;
    let hash = 0;
    for (let i = 0; i < l; i++) {
        const chr = text.charCodeAt(i);
        hash = ((hash << 5) - hash) + chr;
        hash |= 0; // Convert to 32 bit integer
    }
    return hash.toString();
}
//# sourceMappingURL=dialogSet.js.map